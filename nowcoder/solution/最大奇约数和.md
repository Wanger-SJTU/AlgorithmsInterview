
>链接：https://www.nowcoder.com/questionTerminal/49cb3d0b28954deca7565b8db92c5296
来源：牛客网

小易是一个数论爱好者，并且对于一个数的奇数约数十分感兴趣。一天小易遇到这样一个问题： 定义函数`f(x)` 为`x`最大的奇数约数，`x`为正整数。 例如:`f(44) = 11`.
现在给出一个`N`，需要求出` f(1) + f(2) + f(3).......f(N)`
例如： `N = 7`
`f(1) + f(2) + f(3) + f(4) + f(5) + f(6) + f(7) = 1 + 1 + 3 + 1 + 5 + 3 + 7 = 21`
小易计算这个问题遇到了困难，需要你来设计一个算法帮助他。

输入描述:
>输入一个整数`N (1 ≤ N ≤ 1000000000)`

输出描述:
>输出一个整数，即为`f(1) + f(2) + f(3).......f(N)`

示例1
>输入 7
输出 21

---
**题解**:
这道题有很多解法，比如递归或者DP。但是这个输入的范围比较大，递归容易TLE，DP容易MLE。最优的解法是可以做到 $\log n$。

对于奇数来说，最大的奇约数就是它本身，偶数的话需要除以二再看了。

首先回顾以下的公式

$$
1+3+5+7+\cdots=n^2
$$

那对于给定 $n$ ，可以先计算奇数，再计算偶数。偶数除以2的话，得到的又是连续的自然数，又可以递归计算了。

那么对于给定的 $n$, 奇数的个数 $(n+1)//2$。
因此有

```python
import sys
def calc(n):
    res = 0
    while n:
        res += ((n+1)//2)**2
        n//=2
    return res

n = int(sys.stdin.readline().strip())
print(calc(n))
```
