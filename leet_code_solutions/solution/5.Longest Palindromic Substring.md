### Longest Palindromic Substring

>连续最长回文字符串
>
>**Example 1:**
>
>```
>Input: "babad"
>Output: "bab"
>Note: "aba" is also a valid answer.
>```
>
>**Example 2:**
>
>```
>Input: "cbbd"
>Output: "bb"
>```

**brute force**

> 就是暴力搜索。
>
> 三层循环，左右边界以及判断是否为回文字符串

```python
def brute_force(s):
    pal_str =""
    for i in range(len(s)):
        for j in range(i, len(s)):
            while i <= j:
                if s[i] != s[j]:
                    continue
                i += 1
                j -= 1
        if len(pal_str) < j-i+1;
        	pal_str=s[i,j+1]
  	return pal_str
```

 **Dynamic Programming**

> 考虑"ababa"的例子，如果知道'"bab"'是回文串，那么边上两个字母相同，就有整个字符串为回文字串。
>
> 定义$P(i,j)$
> $$
> P(i,j)=\left\{ 
> \begin{aligned}
> 	\text{True}   &\quad  S_{i,j}\text{是回文串}\\
> 	\text{False}  &\quad  \text{其他}
> \end{aligned} 
> \right.
> $$
> 显然有
> $$
> P(i,j)=(P(i+1,j−1) \quad \text{and} \quad S_i==S_j)
> $$
> 而且有 
> $$
> \begin{aligned}
> P(i,i) &= true \\
> P(i, i+1) &= (S_i == S_{i+1} )
> \end{aligned}
> $$
>

```python
  def DP(s):
    table = [[False for i in range(len(s))] for j in range(len(s))]
		sub_str = ""
		lens = 1
		while lens < len(s):
			for start in range(len(s)):
				end = start + lens -1
				if end >= len(s):
					break
				print(start, end)
				table[start][end] = (lens == 1 or lens == 2 or table[start+1][end-1]) \
						 and s[start] == s[end]
				if table[start][end] and len(sub_str) < end-start +1:
					sub_str = s[start:end+1]
			lens += 1
		return sub_str
```

**Expand Around Center**

> 对于任一字符，依此为中心向两边扩展。直到不是回文串为止。记录长度最大的。

```python
def expandAroundCenter(s):
	start = 0 
	end = 0
	for i in range(len(s)):
		len1 = expand(s, i, i)
		len2 = expand(s, i, i+1)
		max_len = max(len1,len2)
		
		if max_len >= end -start + 1:
			start = i - int((max_len - 1) // 2)
			end   = i + int(max_len // 2)
	return s[start:end + 1]

def expand(s, left, right):
	L = left
	R = right
	while L >=0 and R < len(s) and s[L] == s[R]:
		L -= 1
		R += 1
	return R - L - 1
```

**Manacher's Algorithm 马拉车算法**

