给定两个大小为 `m` 和 `n` 的有序数组 `nums1` 和 `nums2`。
请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 $O(log(m + n))$。
你可以假设 `nums1` 和 `nums2` 不会同时为空。

示例 1:

>nums1 = [1, 3]
nums2 = [2]
则中位数是 2.0

示例 2:

>nums1 = [1, 2]
nums2 = [3, 4]
则中位数是 (2 + 3)/2 = 2.5

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/median-of-two-sorted-arrays
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

---

### 排序1

可以对两个数组归并排序，然后计算中位数
```python
def get_median(nums1, nums2):
  nums = []
  idx1 = 0
  idx2 = 0
  while idx1 <len(nums1) and idx2 < len(nums2):
    if nums1[idx1] < nums2[idx2]:
      nums.append(nums1[idx1])
      idx1 += 1
    else:
      nums.append(nums2[idx2])
      idx2 += 1
  while idx1 < len(nums1):
    nums.append(nums1[idx1])
    idx1 += 1
  while idx2 < len(nums2):
    nums.append(nums2[idx2])
    idx2 += 1
  if len(nums) % 2 == 0:
    return (nums[len(nums)//2]+nums[len(nums)//2-1])/2
  else:
    return nums[len(nums)//2+1]
```


时间复杂度：$O(m+n)$
空间复杂度: $O(m+n)$

### 排序2

事实上，可以不进行排序。模拟归并排序过程即可


```python
def mergeSort(nums1, nums2):
    total = len(nums1) + len(nums2)
    idx1,idx2 = 0,0
    i,left,right = 0,-1,-1
    while i <= total//2:
        left = right
        if idx1 < len(nums1) and (idx2 >= len(nums2) or nums1[idx1] < nums2[idx2]):
            right = nums1[idx1]
            idx1+=1
        else:
            right = nums2[idx2]
            idx2+=1
        i += 1
    return (left+right)/2.0 if total& 1 ==0 else right
```


时间复杂度：$O(m+n)$
空间复杂度: $O(1)$


### 二分


```python
def findMedianSortedArrays(nums1, nums2):
    a, b = sorted((nums1, nums2), key=len)
    # a 短数组 b 长数组
    m, n = len(a), len(b)
    after = (m + n - 1) // 2
    lo, hi = 0, m
    while lo < hi:
        i = (lo + hi) // 2
        # b[0:after-i] 长数组 left
        if after-i-1 < 0 or a[i] >= b[after-i-1]:
            hi = i
        else:
            lo = i + 1
    i = lo
    nextfew = sorted(a[i:i+2] + b[after-i:after-i+2])##??
    return (nextfew[0] + nextfew[1 - (m+n)%2]) / 2.0
```

时间复杂度：$O(\log(\min(m,n))$
空间复杂度: $O(1)$

